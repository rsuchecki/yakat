/*
 * Copyright 2020 rad.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package kmerloc;

import argparser.ArgParser;
import argparser.Opt;
import argparser.OptSet;
import argparser.PositionalOpt;
import java.io.PrintStream;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;
import java.util.logging.Logger;
import kmermatch.KmerSetPopulatorConsumer;
import kmermatch.KmerSetsMap;
import shared.FastaIndexed;
import shared.InputReaderProducer;
import shared.Reporter;
import shared.Sequence;
import shared.StdRedirect;

/**
 *
 * @author rad
 */
public class KmerLocator {

    //Read and populate k-mer set //later TODO: multiple k-mer sets - can process range of k values in single pass of the genome
    //Split target FASTA into separate sequences //Later possibly split sequences further?
    //If various len k-mer sets then use the same in memory sequence to extract and query each k-set
    private final String TOOL_NAME;
    private final int HELP_WIDTH = 180;
    private final int IN_Q_CAPACITY;
    private final int INPUT_BUFFER_SIZE = 8092;

    public KmerLocator(String[] args, String callerName, String toolName) {
        ArrayList<String> inputFilenamesList = new ArrayList<>();
        OptSet optSet = populateOptSet();
        ArgParser argParser = new ArgParser();
        argParser.processArgs(args, optSet, true, callerName, HELP_WIDTH);
        TOOL_NAME = callerName + " " + toolName;
        //PARSE OPTS
        new StdRedirect(optSet, TOOL_NAME, StdRedirect.RedirectType.REDIRECT_OUT);
        if (optSet.getOpt("P").isUsed()) {
            optSet.printUserSettings(TOOL_NAME);
        }

        ArrayList<PositionalOpt> positionalOptsList = optSet.getPositionalOptsList();
        for (PositionalOpt po : positionalOptsList) {
            if (po.getValues() != null) {
                inputFilenamesList.addAll(po.getValues());
            }
        }
        IN_Q_CAPACITY = (int) optSet.getOpt("Q").getValueOrDefault();

        locateKmers(inputFilenamesList, optSet);

    }

    private OptSet populateOptSet() {
        OptSet optSet = new OptSet("Report genome coordinates for k-mers (exact matches)");
        //INPUT
        optSet.setListingGroupLabel("[Input settings]");
//        optSet.addOpt(new Opt('d', "domtbl", "The domtbl output generated by hmmer search ", 1).setRequired(true));
        optSet.addOpt(new Opt('f', "fasta", "Target FASTA file (indexed, with accompanying .fai file)", 1).setRequired(true));
        optSet.addOpt(new Opt('b', "first-bases", "Only consider first <arg> bases of a FASTA entry", 1).setMinValue(6));
        optSet.addOpt(new Opt('s', "first-sequences", "Only consider first <arg> sequences in the input FASTA file", 1).setMinValue(1));
        optSet.addOpt(new Opt('a', "ascii-encoding", "Store k-mers in plain ascii - possibly faster than the default encoding, but will consume more memory."));

        optSet.addOpt(new Opt('Q', "in-queue-capacity", "Maximum number of buffers put on queue for processing threads to pick-up",
                2, 1, 256));
        int footId = 1;
        //RUNTIME
        optSet.setListingGroupLabel(optSet.incrementLisitngGroup(), "[Runtime settings]");
//        optSet.addOpt(new Opt('v', "invert-matching", "Output unmatched reads"));
        optSet.addOpt(new Opt('t', "threads", "Max number of threads to be used", 1).setMinValue(1).setDefaultValue(1).setMaxValue(Runtime.getRuntime().availableProcessors()));
        //.addFootnote(footId, "Caution! Large sequences times high number of threads => huge memory consumption"));

        optSet.addOpt(new Opt('P', "print-user-settings", "Print the list of user-settings to stderr and continue executing"));

        //OUTPUT
        optSet.setListingGroupLabel(optSet.incrementLisitngGroup(), "[Output settings]");
//        optSet.addOpt(new Opt('s', "strand", "Output ORFs identified on strand ", 1).setDefaultValue("both"));
////        footId++;
        optSet.addOpt(new Opt('o', "out", "Print output to <arg> file", 1).setDefaultValue("/dev/stdout")); //on Windows use "CON" as default file name
        //POSITIONAL
        optSet.addPositionalOpt(new PositionalOpt("INPUT_KMERS_FILENAMEs", "names of input files (each containing k-mers, optional \tcounts)", 1, (int) Short.MAX_VALUE));
        return optSet;
    }

    private void locateKmers(ArrayList<String> inputFilenamesList, OptSet optSet) {        
        if (inputFilenamesList == null || inputFilenamesList.isEmpty()) { //READSTDIN
            inputFilenamesList = new ArrayList<>();
            inputFilenamesList.add("-");
        }
        //PARSE FASTA FAI INDEX
        String fasta = (String) optSet.getOpt("f").getValueOrDefault();
        FastaIndexed fastaIndexed = new FastaIndexed(TOOL_NAME, fasta, fasta + ".fai");

        int THREADS = (int) optSet.getOpt("t").getValueOrDefault();
        PrintStream bufferedOut = new PrintStream(new java.io.BufferedOutputStream(System.out, 65535));

        boolean storeASCII = optSet.getOpt("a").isUsed();  
        
        Integer firsBasesNum = optSet.getOpt("b").isUsed() ? (int) optSet.getOpt("b").getValueOrDefault() : null;                       
        Integer firsSeqsNum = optSet.getOpt("s").isUsed() ? (int) optSet.getOpt("s").getValueOrDefault() : null;
        

        ArrayList<Integer> kLengths = new ArrayList<>();

        BlockingQueue<ArrayList<String>> inputKmersQueue = new ArrayBlockingQueue(IN_Q_CAPACITY);
        //SPAWN KMERS INPUT READING THREAD        
        ArrayList<Future<?>> inputKmersFutures = new ArrayList<>(1);
        final ExecutorService inputKmersExecutorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());
        InputReaderProducer inputReaderProducer = new InputReaderProducer(inputKmersQueue, kLengths, inputFilenamesList, INPUT_BUFFER_SIZE, TOOL_NAME);
        inputKmersFutures.add(inputKmersExecutorService.submit(inputReaderProducer));

        Reporter.report("[INFO]", "Start populating k-mers set", TOOL_NAME);

        Integer kNULL = null; //prevent k-merizing

        //SPAWN MAP POPULATOR THREADS
        KmerSetsMap kmerSetsMap = new KmerSetsMap(TOOL_NAME);
        final ExecutorService populatorExecutorService = new ThreadPoolExecutor(THREADS, THREADS, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());
        ArrayList<Future<?>> populatorFutures = new ArrayList<>(THREADS);
        for (int i = 0; i < THREADS; i++) {
            populatorFutures.add(populatorExecutorService.submit(new KmerSetPopulatorConsumer(kmerSetsMap, inputKmersQueue, kNULL, storeASCII)));

        }
        populatorExecutorService.shutdown();
        inputKmersExecutorService.shutdown();
        try {

            for (Future<?> f : populatorFutures) {
                f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            }
            populatorExecutorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            for (Future<?> f : inputKmersFutures) {
                f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            }
            inputKmersExecutorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            Reporter.report("[ERROR]", "interrupted exception!", getClass().getSimpleName());
        } catch (ExecutionException ex) {
            Reporter.report("[ERROR]", "execution exception! " + ex.getCause().getMessage(), getClass().getSimpleName());
            ex.printStackTrace();
        } catch (TimeoutException ex) {
            Reporter.report("[ERROR]", "timeout exception!", getClass().getSimpleName());
        }
//
//        if(kLengths.size()>1) {
//            Reporter.report("[FATAL]", "Currently unable to process multiple k-mer sizes "+kLengths.toString(), TOOL_NAME);
//            System.exit(9);
//        }
//        LocatorStats stats = new LocatorStats();
        AtomicLong totalPLaced = new AtomicLong();
        
        final ExecutorService locatorExecutorService = new ThreadPoolExecutor(THREADS, THREADS, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
        ArrayList<Future<?>> locatorFutures = new ArrayList<>(THREADS);
        BlockingQueue<ArrayList<Sequence>> queriesQueue = new ArrayBlockingQueue<>(2);

        for (int i = 0; i < THREADS; i++) {
            locatorFutures.add(locatorExecutorService.submit(new KmerLocatorConsumer(queriesQueue, kmerSetsMap, TOOL_NAME, bufferedOut, storeASCII, totalPLaced)));
//            locatorFutures.add(locatorExecutorService.submit(new KmerLocatorConsumer(queriesQueue, kmerSetsMap, TOOL_NAME, bufferedOut, storeASCII, stats)));
        }

        int totalSequences = fastaIndexed.getIds().size();
        int sequencesPerThread = Math.max(1, totalSequences / THREADS / 4);
        try {
            ArrayList<Sequence> seqAL = new ArrayList<>(sequencesPerThread);
            int seqsCount = 0;
            for (String id : fastaIndexed.getIds()) {
//            Reporter.report("[INFO]", "Reading in " + id, TOOL_NAME);
                Sequence sequence = firsBasesNum == null ? new Sequence(id, fastaIndexed.getSequence(id)) : new Sequence(id, fastaIndexed.getSequence(id, 1, firsBasesNum));
//                System.err.println(sequence.getId()+" --> "+sequence.getLength()+"\n"+sequence.getSequenceString());
                seqAL.add(sequence);
                if (seqAL.size() == sequencesPerThread) {
                    queriesQueue.put(seqAL);
                    seqAL = new ArrayList<>(sequencesPerThread);
                }
                if(firsSeqsNum != null && ++seqsCount >= firsSeqsNum) {
                  break;
                }
            }
            if (!seqAL.isEmpty()) {
                queriesQueue.put(seqAL);
            }
            queriesQueue.put(new ArrayList<>());
        } catch (InterruptedException ex) {
            Logger.getLogger(KmerLocator.class.getName()).log(Level.SEVERE, null, ex);
        }
        locatorExecutorService.shutdown();
        try {
            for (Future<?> f : locatorFutures) {
                f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
            }
            locatorExecutorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
            Reporter.report("[ERROR]", "interrupted exception!", getClass().getSimpleName());
        } catch (ExecutionException ex) {
            Reporter.report("[ERROR]", "execution exception! " + ex.getCause().getMessage(), getClass().getSimpleName());
            ex.printStackTrace();
        } catch (TimeoutException ex) {
            Reporter.report("[ERROR]", "timeout exception!", getClass().getSimpleName());
        }
        
        bufferedOut.close();        
        Reporter.report("[INFO]", "Finished placing k-mers, "+NumberFormat.getInstance().format(totalPLaced.get())+" placed.", TOOL_NAME);
//        Reporter.report("[INFO]", "Finished placing k-mers, "+NumberFormat.getInstance().format(stats.getTotalPlaced())+" placed.", TOOL_NAME);
    }
}
