/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package hmmerdoms;

import argparser.ArgParser;
import argparser.Opt;
import argparser.OptSet;
import argparser.PositionalOpt;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import shared.CommonMaths;
import shared.FastaIndexed;
import shared.Orf;
import shared.Reporter;
import shared.Sequence;
import shared.SequenceOps;
import shared.StdRedirect;
import snpmers.SnpFilter;

/**
 *
 * @author Radoslaw Suchecki <radoslaw.suchecki@adelaide.edu.au>
 */
public class HmmerDomains {

    private final String TOOL_NAME;
//    private int MATCHER_THREADS = 1;

    //IN
    private final int IN_BUFFER_SIZE;
    private final int IN_Q_CAPACITY;

    //OUT
    private final int WRITER_BUFFER_SIZE = 1024;
//    private final int OUT_BUFFER_SIZE;
//    private final int OUT_Q_CAPACITY;
    private final int HELP_WIDTH = 180;

    public HmmerDomains(String[] args, String callerName, String toolName) {
        ArrayList<String> inputFilenamesList = new ArrayList<>();
        OptSet optSet = populateOptSet();
        ArgParser argParser = new ArgParser();
        argParser.processArgs(args, optSet, true, callerName, HELP_WIDTH);
        TOOL_NAME = callerName + " " + toolName;
        //PARSE OPTS
        IN_BUFFER_SIZE = (int) optSet.getOpt("U").getValueOrDefault();
        IN_Q_CAPACITY = (int) optSet.getOpt("Q").getValueOrDefault();

//        MATCHER_THREADS = (int) optSet.getOpt("t").getValueOrDefault();
//        OUT_BUFFER_SIZE = (int) optSet.getOpt("u").getValueOrDefault();
//        OUT_Q_CAPACITY = (int) optSet.getOpt("q").getValueOrDefault();
        new StdRedirect(optSet, TOOL_NAME, StdRedirect.RedirectType.REDIRECT_OUT);
        if (optSet.getOpt("P").isUsed()) {
            optSet.printUserSettings(TOOL_NAME);
        }

        ArrayList<PositionalOpt> positionalOptsList = optSet.getPositionalOptsList();
        for (PositionalOpt po : positionalOptsList) {
            if (po.getValues() != null) {
                inputFilenamesList.addAll(po.getValues());
            }
        }


        processHmmerDomains(inputFilenamesList, optSet);

    }

    private OptSet populateOptSet() {
        OptSet optSet = new OptSet("Given tabular .domtbl output from hmmmer search against six-frame translation of a genome, extract putative genomic regions coordinates."
                + "\n(1) Second and third \"_\" delimited field in identifier reflect the offset introduced when conigerizing a chromosome and the number of removed Ns respectively"
                + "\n(2) Expecting translation frame in FASTA description \\in {fr1,fr2,...,fr6} (following FASTA id and whitespace)");
        //INPUT
        optSet.setListingGroupLabel("[Input settings]");
//        optSet.addOpt(new Opt('d', "domtbl", "The domtbl output generated by hmmer search ", 1).setRequired(true));
        optSet.addOpt(new Opt('f', "fasta", "Reference FASTA file ", 1).setRequired(true));
        optSet.addOpt(new Opt('n', "no-extend", "Do not extend genomic regions when an ORF overlapping with domain-hits cmisses a stop codon"));

//        optSet.addOpt(new Opt('A', "expected-adapter", "Expected adapter sequence (a fragment will do)", 1).setDefaultValue("AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGAT"));
//        optSet.addOpt(new Opt(null, "adapter-prefix-length", "Length of the adapter prefix used to identify 3' read-through", 1).setDefaultValue(9));
//        optSet.addOpt(new Opt('B', "blank-samples-name", "Name denoting blank samples in the key file. Name will by extended with remaining key-file fields", 1).setDefaultValue("Blank"));
        optSet.addOpt(new Opt('U', "in-buffer-size", "Number of FASTQ records (reads or pairs depending on input) "
                + "passed to in-queue", 1024, 128, 8092));
        optSet.addOpt(new Opt('Q', "in-queue-capacity", "Maximum number of buffers put on queue for processing threads to pick-up",
                2, 1, 256));
//        //TRIMMING AND LENGTH
//        optSet.setListingGroupLabel(optSet.incrementLisitngGroup(), "[Trimming and length settings]");
//        optSet.addOpt(new Opt('b', "keep-barcodes", "Do not trim barcodes"));
//        optSet.addOpt(new Opt('a', "keep-adapters", "Do not trim adapters found next to PstI and MspI sites "));
//        optSet.addOpt(new Opt('p', "keep-non-PstI-starting", "Keep reads (or pairs) which do not start with 'barcodeTGCAG'"));
//
        int footId = 1;
//        String footText1 = "Note that certain combinations of min-length-* settings can lead to both mates of a pair ending up in SE/orphans output file.";
//        optSet.addOpt(new Opt('r', "min-length-single-read", "Only output a read if length is no less than <arg> bp", 1, 1, null, 1, 1).addFootnote(footId, footText1));
//        optSet.addOpt(new Opt('e', "min-length-pair-each", "Only output a read pair if length of each is no less than <arg> bp, otherwise process as single", 1, 1, null, 1, 1).addFootnote(footId, footText1));
//        optSet.addOpt(new Opt('s', "min-length-pair-sum", "Only output a read pair if combined length is no less than <arg> bp, otherwise process as single", 2, 2, null, 1, 1).addFootnote(footId, footText1));
        //RUNTIME
        optSet.setListingGroupLabel(optSet.incrementLisitngGroup(), "[Runtime settings]");
//        optSet.addOpt(new Opt('v', "invert-matching", "Output unmatched reads"));
//        optSet.addOpt(new Opt('t', "threads", "Number of splitter threads. No point setting too high, "
//                + "i/o is the likely bottleneck and a writing thread will be spawned per each sample", 1, 1, Runtime.getRuntime().availableProcessors(), 1, 1));
        optSet.addOpt(new Opt('P', "print-user-settings", "Print the list of user-settings to stderr and continue executing"));

        //OUTPUT
        optSet.setListingGroupLabel(optSet.incrementLisitngGroup(), "[Output settings]");
        optSet.addOpt(new Opt('m', "min-doms-per-orf", "Minimum domain-hits per ORF", 1).setDefaultValue(1).setMinValue(1));
        optSet.addOpt(new Opt('M', "max-doms-per-orf", "Maximum domain-hits per ORF", 1).setDefaultValue(Integer.MAX_VALUE).setMinValue(1));
        optSet.addOpt(new Opt('g', "max-gap", "Maximum bp gap allowed between grouped domain-hits", 1).setDefaultValue(200));
//        optSet.addOpt(new Opt('d', "min-doms", "Minimum domain-hits for a group to be reported", 1).setDefaultValue(1).setMinValue(1));

//        optSet.addOpt(new Opt('x', "out-suffix-r1", "Output file suffix for R1 reads", 1).setDefaultValue("_R1.fastq.gz"));
//        optSet.addOpt(new Opt('X', "out-suffix-r2", "Output file suffix for R2 reads", 1).setDefaultValue("_R2.fastq.gz"));
//        optSet.addOpt(new Opt('S', "out-suffix-se", "Output file suffix for SE/orphaned reads", 1).setDefaultValue("_SE.fastq.gz"));
//        optSet.addOpt(new Opt(null, "append", "If output file(s) exist(s) for a given sample, append"));
//        optSet.addOpt(new Opt(null, "force", "If output file(s) exist(s) for a given sample, force overwrite"));
//        optSet.addOpt(new Opt('M', "[TODO] matchless-output", "Output reads with unmatched barcodes to R1/R2/SE file(s) prefixed with <arg>. If not set, these reads will be discarded", 1));
//        footId++;
        optSet.addOpt(new Opt('o', "out-gff3", "Print output to <arg> file", 1).setDefaultValue("/dev/stdout")); //on Windows use "CON" as default file name
        optSet.addOpt(new Opt('N', "out-orfs-nucleotides", "Output ORF nucleotide FASTA to <arg> file", 1)); //on Windows use "CON" as default file name
        optSet.addOpt(new Opt('A', "out-orfs-amino-acids", "Output ORF amino-acid FASTA to <arg> file", 1)); //on Windows use "CON" as default file name

//        String footText2 = "Consider increasing to sacrifice memory for speed. Decrease if encountering 'out of memory' errors.";
//        optSet.addOpt(new Opt('u', "out-buffer-size", "Number of records  "
//                + "passed to out-queue", 1024, 64, 8092).addFootnote(footId, footText2));
//        optSet.addOpt(new Opt('q', "out-queue-capacity", "Maximum number of buffers put on queue for writer threads to pick-up",
//                2, 1, 256).addFootnote(footId, footText2));
        //POSITIONAL
        optSet.addPositionalOpt(new PositionalOpt("INPUT_FILENAMEs", "names of input files (hmmer search domtbl)", 1, (int) Short.MAX_VALUE));
        return optSet;
    }

    private void processHmmerDomains(ArrayList<String> inputFilenamesList, OptSet optSet) {
        //PARSE INPUT FROm HMMER
        DomainHitsPerTarget domainHitsPerTarget = new DomainHitsPerTarget();
        Pattern spliPattern = Pattern.compile("\t| +");
        BufferedReader content = null;

        if (inputFilenamesList == null || inputFilenamesList.isEmpty()) { //READSTDIN
            inputFilenamesList = new ArrayList<>();
            inputFilenamesList.add("-");
        }
        Object empty = new ArrayList<>(0);
        for (String inputFile : inputFilenamesList) {
            try {
                if (inputFile.equals("-")) { //READSTDIN
                    content = new BufferedReader(new InputStreamReader(System.in, "UTF-8"), IN_BUFFER_SIZE);

                } else if (inputFile.endsWith(".gz")) {
                    InputStream gzipStream = new GZIPInputStream(new FileInputStream(inputFile));
                    content = new BufferedReader(new InputStreamReader(gzipStream, "UTF-8"));
                } else {
                    content = new BufferedReader(new FileReader(new File(inputFile)));
                }
                String line;
                while ((line = content.readLine()) != null && !line.isEmpty()) {
                    if (!line.startsWith("#")) {
                        String[] toks = spliPattern.split(line);
                        DomainHit domainHit = new DomainHit(toks);
                        domainHitsPerTarget.addHit(domainHit);
                    }
                }
            } catch (FileNotFoundException ex) {
                Reporter.report("[ERROR]", "File not found exception: " + ex.getMessage(), TOOL_NAME);
                System.exit(1);
            } catch (IOException ex) {
                System.err.println(ex.getMessage());
            } finally {
                try {
                    if (content != null) {
                        content.close();
                    }
                } catch (IOException ex) {
                    System.err.println(ex.getMessage());
                }
            }
        }
        //PARSE FASTA FAI INDEX
        String fasta = (String) optSet.getOpt("f").getValueOrDefault();
        FastaIndexed fastaIndexed = new FastaIndexed(TOOL_NAME, fasta, fasta + ".fai");

        //GROUP DOMAINS BASED ON maxGap
        int maxGap = (int) optSet.getOpt("g").getValueOrDefault();
        ArrayList<HitsGroup> domainsHitsGroups = domainHitsPerTarget.processDomainsPerStrand(true, maxGap, fastaIndexed);
        domainsHitsGroups.addAll(domainHitsPerTarget.processDomainsPerStrand(false, maxGap, fastaIndexed));
//        ArrayList<HitsGroup> domainsGroupedPlusStrand = domainHitsPerTarget.processDomainsPerStrand(true, maxGap, fastaIndexed);
//        ArrayList<HitsGroup> domainsGroupedMinusStrand = domainHitsPerTarget.processDomainsPerStrand(false, maxGap, fastaIndexed);
        Collections.sort(domainsHitsGroups);

        boolean greedyExtendIfIUnterminatedORF = true;
        if (optSet.getOpt("n").isUsed()) {
            greedyExtendIfIUnterminatedORF = false;
        }
        //JUST STATS
        int[] orfsPerGroup = new int[1000];
        int[] domainsPerGroup = new int[1000];
        int[] domainsPerOrf = new int[1000];
        int[] percDomainsCovered = new int[101];
//        int unterminatedOrfCount = 0;
        int outputOrfs = 0;
        int reportedOrfs = 0;
        int reportedGroups = 0;

        int minDomsInOrf = (int) optSet.getOpt("m").getValueOrDefault();
        int maxDomsInOrf = (int) optSet.getOpt("M").getValueOrDefault();

        //INIT OUTPUT FILES
        BufferedWriter outNucl = null;
        BufferedWriter outAA = null;
        try {
            outNucl = optSet.getBufferedWriterForOpt("N", WRITER_BUFFER_SIZE);
            outAA = optSet.getBufferedWriterForOpt("A", WRITER_BUFFER_SIZE);

            String fmt = "%0" + ("" + domainsHitsGroups.size()).length() + "d";
            System.out.println(
                    "##gff-version 3");
            String blank = ".";
            String source = "hmmerdoms";
            for (int i = 0; i < domainsHitsGroups.size(); i++) {
                HitsGroup hitsGroup = domainsHitsGroups.get(i);
                ArrayList<OrfWithDomainHits> orfToCoveredDomainsList = hitsGroup.getOrfsWithDomainsHits(fastaIndexed, maxGap / 2, greedyExtendIfIUnterminatedORF);
                outputOrfs += orfToCoveredDomainsList.size();
                //stats
                domainsPerGroup[hitsGroup.size()]++;
                orfsPerGroup[orfToCoveredDomainsList.size()]++;

                StringBuilder groupId = new StringBuilder("ID=HDG_");
                groupId.append(String.format(fmt, (i + 1)));

                StringBuilder sb = gffEntry(new CharSequence[]{hitsGroup.getTargetId(), source, "region",
                    hitsGroup.getOrfPredictionFromPosition().toString(), hitsGroup.getOrfPredictionToPosition().toString(),
                    blank, hitsGroup.getStrandSymbol(), blank, groupId});

                StringBuilder sbNuclOrfs = new StringBuilder();
                StringBuilder sbAAOrfs = new StringBuilder();

                Collections.sort(orfToCoveredDomainsList);
                boolean hasOrfs = false;
                for (int j = 0; j < orfToCoveredDomainsList.size(); j++) {
                    StringBuilder orfAttributes = new StringBuilder(groupId);
                    orfAttributes.append("_ORF_").append((j + 1));
                    OrfWithDomainHits orfToCoveredDomains = orfToCoveredDomainsList.get(j);
                    int domsInOrf = orfToCoveredDomains.getDomainHits().size();
                    if (domsInOrf < minDomsInOrf || domsInOrf > maxDomsInOrf) {
                        break;
                    }
                    hasOrfs = true;
                    reportedOrfs++;
                    Orf orf = orfToCoveredDomains.getOrf();
//                if (!orf.hasStopCodon()) {
//                    unterminatedOrfCount++;
//                }
                    domainsPerOrf[orfToCoveredDomains.getDomainHits().size()]++;
                    int round = (int) CommonMaths.round(((double) hitsGroup.getNumAssigned() / hitsGroup.size() * 100), 2);
                    percDomainsCovered[round]++;

                    //ACTUAL ORF POS IN REF=(ORF POS IN CONTIG)+(CONTIG START POS IN REF)
                    Long orfFrom = orf.getFrom() + hitsGroup.getOrfPredictionFromPosition() - 1;
                    Long orfTo = orf.getTo() + hitsGroup.getOrfPredictionFromPosition() - 1;

                    sb.append(System.lineSeparator()).append(gffEntry(new CharSequence[]{orf.getParenId(), source, "ORF",
                        orfFrom.toString(), orfTo.toString(), blank, orf.getFrame() > 0 ? "+" : "-", blank, orfAttributes}));

                    //OUTPUT ORFs as NUCL AND/OR AA FASTA 
                    if (outNucl != null || outAA != null) {
                        StringBuilder fastaId = new StringBuilder(">");
                        fastaId.append(orfAttributes.substring(3));
                        fastaId.append(" ").append(hitsGroup.getTargetId());
                        fastaId.append(":").append(orfFrom);
                        fastaId.append("-").append(orfTo);
                        fastaId.append(System.lineSeparator());

                        sbNuclOrfs.append(fastaId);
                        sbAAOrfs.append(fastaId);
                        Sequence orfSequence = new Sequence(orf.getParenId().toString(), fastaIndexed.getSequence(orf.getParenId().toString(), orfFrom, orfTo));
                        String sequenceString = orfSequence.getSequenceString();
                        int frame = orfToCoveredDomains.getOrf().getFrame();
                        if (frame > 0) {
                            sbNuclOrfs.append(sequenceString);
                            sbAAOrfs.append(SequenceOps.translate(sequenceString));
                        } else {
                            sbNuclOrfs.append(SequenceOps.getReverseComplementString(sequenceString));
                            sbAAOrfs.append(SequenceOps.translate(SequenceOps.getReverseComplementString(sequenceString)));
                        }
                        sbNuclOrfs.append(System.lineSeparator());
                        sbAAOrfs.append(System.lineSeparator());
                    }

                    for (int k = 0; k < orfToCoveredDomains.getDomainHits().size(); k++) {
                        DomainHit dh = orfToCoveredDomains.getDomainHits().get(k);
                        StringBuilder DomHitAttributes = new StringBuilder(groupId);
                        DomHitAttributes.append("_ORF_").append((j + 1)).append("_DOMAINS_").append((k + 1));;

                        sb.append(System.lineSeparator()).append(gffEntry(new CharSequence[]{dh.getTargetIdCorrected(), source, "match",
                            dh.getCorrectedStart().toString(), dh.getCorrectedEnd().toString(), blank, dh.getTargetFrame() > 0 ? "+" : "-", blank, DomHitAttributes}));
                    }
//                Long extractStart = new Long(hitsGroup.getFrom()) - maxGap / 2;
//                long orfFrom = orf.getFrom() + extractStart - 1;
//                long orfTo = orf.getTo() + extractStart - 1;
//
//                    System.out.println("ORF:    " + orf.getParenId() + "\t" + orfFrom + "\t" + orfTo + "\t" +(orfTo-orfFrom+1)+ "\t" + (orf.hasStopCodon() ? "" : "non-stop"));
//                for (int i = 0; i < domainHits.size(); i++) {
//                    DomainHit dh = domainHits.get(i);
////                        System.out.println("        " + dh.getTargetIdCorrected() + "\t" + dh.getCorrectedStart() + "\t" + dh.getCorrectedEnd() + "\t" + dh.getTargetFrame() + "\t<=== DOM "+(i+1));
//                }
                }
                if (hasOrfs) {
                    System.out.println(sb);
                    reportedGroups++;
                }
                if (outNucl != null) {
                    outNucl.append(sbNuclOrfs);
                }
                if (outAA != null) {
                    outAA.append(sbAAOrfs);
                }
//          }
            }
        } catch (UnsupportedEncodingException e) {
            Reporter.report("[ERROR]", e.getMessage(), TOOL_NAME);
        } catch (IOException e) {
            Reporter.report("[ERROR]", e.getMessage(), TOOL_NAME);
        } finally {
            try {
                outNucl.close();
                outAA.close();
            } catch (IOException ex) {
                Reporter.report("[ERROR]", ex.getMessage(), TOOL_NAME);
            }
        }
        //PRINT STATS
//        int max = 0;
//        for (int i = 0; i < domainsPerOrf.length; i++) {
//            max = domainsPerOrf[i] > 0 ? i : max;
//            max = domainsPerGroup[i] > 0 ? i : max;
//            max = orfsPerGroup[i] > 0 ? i : max;
//        }
//        for (int i = 0; i < max + 1; i++) {
//            System.out.printf("%d %d %d %d \n", i, domainsPerGroup[i], orfsPerGroup[i], domainsPerOrf[i]);
//        }
//        for (int i = 0; i < percDomainsCovered.length; i++) {
////            System.out.printf("%d %d\n", i, percDomainsCovered[i]);
//            System.out.println(percDomainsCovered[i]);
//        }
        Reporter.report(
                "[INFO]", "Number of groups  = " + NumberFormat.getInstance().format(domainsHitsGroups.size()), TOOL_NAME);
//        Reporter.report("[INFO]", "Number of unterminated ORFs = " + NumberFormat.getInstance().format(unterminatedOrfCount), TOOL_NAME);
        Reporter.report(
                "[INFO]", "Number of domain-containing ORFs = " + NumberFormat.getInstance().format(outputOrfs), TOOL_NAME);
        Reporter.report(
                "[INFO]", "Number of reported groups  = " + NumberFormat.getInstance().format(reportedGroups), TOOL_NAME);
        Reporter.report(
                "[INFO]", "Number of reported domain-containing  ORFs = " + NumberFormat.getInstance().format(reportedOrfs), TOOL_NAME);
    }

    private StringBuilder gffEntry(CharSequence[] fields) {
        StringBuilder sb = new StringBuilder(fields[0]);
        for (int i = 1; i < fields.length; i++) {
            sb.append("\t").append(fields[i]);
        }
        return sb;
    }

}
