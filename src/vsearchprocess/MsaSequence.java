/*
 * Copyright 2016 rad.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package vsearchprocess;

import shared.Sequence;

/**
 *
 * @author rad
 */
public class MsaSequence extends Sequence {

    private boolean[] paddingArray;
    private int nonTipPaddingLength = -1;
//    private final Integer originalLength;

//    public MsaSequence(String id, String sequenceString, Integer originalLength) {
//        super(id, sequenceString);
//        this.originalLength = originalLength;
//    }
    public MsaSequence(String id, String sequenceString) {
        super(id, sequenceString);
    }

//    /**
//     * 
//     * @return null if not known
//     */
//    public Integer getOriginalLength() {
//        return originalLength;
//    }
    /**
     * For a given sequence specify which positions are padding generated by the
     * MSA
     *
     * @param sequence
     * @param maxIndelLength
     * @param minIndelDistFromEnds
     * @return padding boolean array
     */
    public boolean[] getPaddingArray(int maxIndelLength, int minIndelDistFromEnds) {
        if (paddingArray == null) {
            generatePaddingArray(maxIndelLength, minIndelDistFromEnds);
        }
        return paddingArray;
    }

    public void generatePaddingArray(int maxIndelLength, int minIndelDistFromEnds) {
//        System.err.println(getSequenceString());

        //record positions regarded as padding (rather than indels)
        nonTipPaddingLength = 0;
        int alnLen = this.getLength();
        paddingArray = new boolean[alnLen];
//            System.err.println(sequence.getSequenceString());
        //PROVISIONALLY TREAT ALL "-" AS PADDING
        Integer trimmedStart = null;
        Integer trimmedEnd = null;
        for (int j = 0; j < alnLen; j++) {
            if (this.getSequenceString().charAt(j) == '-') {
                paddingArray[j] = true;
//                nonTipPaddingLength++;
            } else {
                if (trimmedStart == null) {
                    trimmedStart = j;
                }
                trimmedEnd = j;
            }
        }
        //SKIPPING TERMINAl PADDING, SO BY DEFINITION ALL PAD/GAP STRETCHES ARE CONTAINED WITHIN [ACGT]+
        //IF PADDING STRETCH NO LONGEr THAN MAX_INDEL_LEN THE MARK IT AS NOT PADDING
        int padLen = 0;
        for (int i = trimmedStart; i < trimmedEnd + 1; i++) {
            if (paddingArray[i]) {
                padLen++;
            } else if (padLen > 0) {
                if (padLen <= maxIndelLength) {
                    int padStart = i - padLen;
                    int padEnd = i-1;
                    if (padStart >= trimmedStart + minIndelDistFromEnds  && padEnd <= trimmedEnd - minIndelDistFromEnds) {
                        for (int j = i - 1; j > i - padLen - 1; --j) {
                            paddingArray[j] = false;
                        }
                    }
                } else {
                    nonTipPaddingLength += padLen;
                }
                padLen = 0;
            }
        }
//
//        for (int i = 0; i < paddingArray.length; i++) {
//            if (paddingArray[i]) {
//                System.err.print("P");
//            } else {
//                System.err.print(" ");
//            }
//        }
//        System.err.println("");
    }

//        int padLength = 0;
//
//        System.err.println(getSequenceString());
//        System.err.println("Unpadded start "+trimmedStart);
//        System.err.println("UnpaddedEnd"+trimmedEnd);
//        boolean debug = false;
//        if (getId().equals("ms5mut_131956_Cluster_2_k45")) {            
//            debug = true;
//            System.err.println(getId());
//        }
//
//        for (int positionInSeq = 0; positionInSeq < paddingArray.length + 1; positionInSeq++) {
//            boolean processingLastPosition = false;
//            if (positionInSeq == paddingArray.length) {  //Get last position
//                processingLastPosition = true;
//            }
//            if (!processingLastPosition && paddingArray[positionInSeq]) {
//                padLength++;
//                if (debug) {
//                    System.err.print("P");
//                }
////                    System.err.println("["+positionInSeq+"] PADDING");
//            } else {
//                if (debug) {
//                    System.err.print(" ");
//                }
////                    System.err.println("["+positionInSeq+"] NOT PADDING");
//                //IF padding strech shorter than maxIndelLength THEN it may be an indel and not padding
//                if (padLength > 0 && padLength <= maxIndelLength) {
////                    if(debug)
////                        System.err.println("["+positionInSeq+"] Investigating if real @padLen="+padLength);
//                    boolean headPadding = false;
//                    for (int positionInPadStretch = padLength; positionInPadStretch > 0; positionInPadStretch--) {
//                        //IGNORE indels adjacent to SEQ ENDS, that is, treat them as alignment padding
//                        if (positionInSeq - positionInPadStretch < minIndelDistFromEnds || headPadding || positionInSeq > alnLen - minIndelDistFromEnds) {
////                            if(debug)
////                                System.err.println("["+positionInSeq+"] HEAD PADDING ["+positionInPadStretch+"] ");
//                            headPadding = true;
////                                System.err.println("Not unpadding pos = " + (positionInSeq - positionInPadStretch + 1) + " in seq " + sequence.getIdentifierString());
//                            break; //IF WE CLASS THIS POSITION AS PADDING, THE REST OF THE STRETCH IS PADDING AS WELL                                
//                        } else {
////                            if(debug)
////                                System.err.println("["+positionInSeq+"] NOT HEAD PADDING ["+positionInPadStretch+"] ");
//                            paddingArray[positionInSeq - positionInPadStretch] = false;
//                            --nonTipPaddingLength;
//                            headPadding = false;
////                                System.err.println("Unpadding pos = " + (positionInSeq - positionInPadStretch + 1) + " in seq " + sequence.getIdentifierString());
//                        }
//                    }
//                }
//                padLength = 0;
//            }
//        }
//        if (debug) {
//            System.err.println("");
//        }
//    }
    /**
     * Substantial non-tip padding suggests spurious alignment
     *
     * @param maxIndelLength
     * @return
     */
    public int getNonTipPaddingLength() {
//        if (nonTipPaddingLength == -1) {
//            nonTipPaddingLength = 0;
//            String[] split = getSequenceString().split("[^-]");
//            for (int i = 1; i < split.length - 1; i++) { //skipping first and last elems (these represent padding at tips)
//                int length = split[i].length();
//                if (length > maxIndelLength) { //ALLOW INDELS UP TO SPECIFIED THRESHOLD
//                    nonTipPaddingLength += split[i].length();
//                }
//            }
//        }
        return nonTipPaddingLength;
    }

    public int getUnpaddedLength() {
        if (!getSequenceString().contains("-")) {
            return getLength();
        }
        int unpaddedLen = 0;
        for (int i = 0; i < paddingArray.length; i++) {
            if (!paddingArray[i]) {
                unpaddedLen++;
            }
        }
        return unpaddedLen;
    }
}
